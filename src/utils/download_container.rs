//! In the middle of competition, we will typically use an
//! outbound firewall policy that blocks all traffic going out
//! from the machine. This module creates a new network namespace
//! and configures the host system to route traffic from this
//! namespace. The download container then allows for entering
//! the namespace to execute functions temporarily before stepping
//! back out
//!
//! This does require root permissions, or at least `CAP_SYS_ADMIN`
//!
//! ```no_run
//! # use jj_rs::utils::{busybox, download_container::DownloadContainer};
//! # fn test_download_container() -> eyre::Result<()> {
//! let container = DownloadContainer::new(Some("dlshell".to_string()), None)?;
//! let container_ip = container.run(|| {
//!     busybox::execute(&["ip", "addr"])
//! })??;
//! assert!(container_ip.contains("172.16"));
//! assert!(container_ip.contains("dlshell"));
//! # Ok(())
//! # }
//! # test_download_container().expect("could not run download container");
//! ```

use std::{
    net::Ipv4Addr,
    os::{fd::OwnedFd, unix::fs::PermissionsExt},
    path::PathBuf,
    process::Stdio,
};

use eyre::{Context, bail, eyre};
use nix::{
    fcntl::{OFlag, open},
    sched::{CloneFlags, setns},
    sys::{
        signal::{Signal::SIGTERM, kill},
        stat::Mode,
        wait::waitpid,
    },
    unistd::{ForkResult, Pid, fork, geteuid, getpid},
};

use crate::{
    pcre,
    utils::{busybox::Busybox, nft::Nft},
};

const IP_ADDR_REGEX: &str = concat!(
    "(?:[0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])",
    r"\.",
    "(?:[0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])",
    r"\.",
    "(?:[0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])",
    r"\.",
    "(?:[0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
);

/// A handle on the download container and all the resources necessary to operate it.
pub struct DownloadContainer {
    ns_name: String,
    child: Pid,
    original_net_ns: OwnedFd,
    child_net_ns: OwnedFd,
    original_mnt_ns: OwnedFd,
    child_mnt_ns: OwnedFd,
    nft: Nft,
    wan_ip: Ipv4Addr,
    #[allow(dead_code)]
    lan_ip: Ipv4Addr,
}

impl DownloadContainer {
    /// Construct a new download container
    ///
    /// Performing this action requires root privileges
    ///
    /// The name is what controls the name of the nft chain and the veth pair interfaces.
    /// It must be less than 14 characters to allow creation of a valid container
    ///
    /// This also means with the autogenerated IPs, you can only have 9,999,999,999 PIDs in
    /// use on your system, and this program will start to act weird after that point is
    /// reached. Fortunately, the default max point seems to be closer to either 4,194,304 or
    /// 32,768
    ///
    /// The `sneaky_ip` setting allows for the system to perform source NAT as that IP address.
    /// It will start to do ARP spoofing as that address to assist the local LAN in routing
    /// return traffic back. If unspecified, it will masquerade as the host IP address
    ///
    /// If sneaky_ip is not set but the environment variable SNEAKY_IP is available, that variable
    /// will be used
    pub fn new(name: Option<String>, sneaky_ip: Option<Ipv4Addr>) -> eyre::Result<Self> {
        if !geteuid().is_root() {
            bail!("You must be root to make use of download container capabilities");
        }

        let ns_name = name.unwrap_or_else(|| format!("jjsh{}", getpid()));

        let bb = Busybox::new().context("Could not prepare busybox for download container")?;

        if pcre!((&bb.execute(&["ip", "link"])?) =~ qr{r"^[0-9]+:\s+" ns_name ".0:"}xms) {
            bail!("There is already a download shell with that name");
        }

        bb.execute(&[
            "ip",
            "link",
            "add",
            &format!("{ns_name}.0"),
            "type",
            "veth",
            "peer",
            "name",
            &format!("{ns_name}.1"),
        ])
        .context("Could not add veth pair")?;
        let child = get_namespace(&bb)?;

        let original_net_ns = open(
            &*format!("/proc/{}/ns/net", getpid()),
            OFlag::O_RDONLY,
            Mode::empty(),
        )
        .context("Could not open parent net namespace")?;
        let original_mnt_ns = open(
            &*format!("/proc/{}/ns/mnt", getpid()),
            OFlag::O_RDONLY,
            Mode::empty(),
        )
        .context("Could not open parent mount namespace")?;
        let child_net_ns = open(
            &*format!("/proc/{child}/ns/net"),
            OFlag::O_RDONLY,
            Mode::empty(),
        )
        .context("Could not open child net namespace")?;
        let child_mnt_ns = open(
            &*format!("/proc/{child}/ns/mnt"),
            OFlag::O_RDONLY,
            Mode::empty(),
        )
        .context("Could not open child mount namespace")?;

        bb.execute(&["ip", "link", "set", &format!("{ns_name}.0"), "up"])
            .context("Could not set host link up")?;

        // BUG: `busybox ip` does not properly set the name of the peer device
        // This has been known about since 2022...
        // https://lists.debian.org/debian-boot/2022/01/msg00091.html
        {
            let links = bb
                .execute(&["ip", "link"])
                .context("Could not query links")?;
            let peer_name = pcre!(&links =~ m{r"^[0-9]+:\s+" ns_name r"\.0@([^:]+):"}xms)
                .get(0)
                .ok_or(eyre!(
                    "Could not find peer name for interface in download container"
                ))?
                .extract::<1>()
                .1[0];
            bb.execute(&[
                "ip",
                "link",
                "set",
                peer_name,
                "name",
                &format!("{ns_name}.1"),
            ])
            .context("Could not rename link")?;
        }

        bb.execute(&[
            "ip",
            "link",
            "set",
            &format!("{ns_name}.1"),
            "netns",
            &format!("{child}"),
        ])
        .context("Could not move interface to child namespace")?;

        let tunnel_net = find_tunnel_net(&bb)?;

        let wan_ip = Ipv4Addr::from(u32::from(tunnel_net) + 1);
        let lan_ip = Ipv4Addr::from(u32::from(tunnel_net) + 2);

        bb.execute(&[
            "ip",
            "addr",
            "add",
            &format!("{wan_ip}/30"),
            "dev",
            &format!("{ns_name}.0"),
        ])
        .context("Could not add IP address to WAN interface")?;

        setns(&child_net_ns, CloneFlags::CLONE_NEWNET)
            .context("Could not change to child namespace to set up local networking")?;

        bb.execute(&["ip", "link", "set", "lo", "up"])
            .context("Could not bring up localhost in container")?;

        bb.execute(&["ip", "link", "set", &format!("{ns_name}.1"), "up"])
            .context("Could not bring up interface in container")?;

        bb.execute(&[
            "ip",
            "addr",
            "add",
            &format!("{lan_ip}/30"),
            "dev",
            &format!("{ns_name}.1"),
        ])
        .context("Could not assign interface IP in container")?;

        bb.execute(&["ip", "route", "add", "default", "via", &format!("{wan_ip}")])
            .context("Could not create default route in container")?;

        setns(&original_net_ns, CloneFlags::CLONE_NEWNET)
            .context("Could not change back to host namespace")?;

        let routes = bb
            .execute(&["ip", "route"])
            .context("Could not query host routes")?;

        let public_if = pcre!(&routes =~ m/r"default[^\n]*dev\s+([^\s]+)"/xms)
            .get(0)
            .ok_or(eyre!("Could not find default route!"))?
            .extract::<1>()
            .1[0];

        std::fs::write("/proc/sys/net/ipv4/ip_forward", "1")
            .context("Could not enable IP forwarding")?;

        let nft = Nft::new()?;

        nft.exec(format!("delete table inet {ns_name}"), Stdio::null())
            .context("Could not delete previous sneaky table")?;
        nft.exec(format!("add table inet {ns_name}"), None)
            .context("Could not add new sneaky table")?;
        nft.exec(format!("add chain inet {ns_name} postrouting {{ type nat hook postrouting priority srcnat; policy accept; }}"), None)
            .context("Could not add sneaky chain")?;

        let sneaky_ip = sneaky_ip.or_else(|| {
            std::env::var("SNEAKY_IP")
                .ok()
                .and_then(|var| var.parse::<Ipv4Addr>().ok())
        });

        match sneaky_ip {
            Some(ip) => {
                nft.exec(
                    format!("add rule inet {ns_name} postrouting ip saddr {lan_ip} snat to {ip}"),
                    None,
                )
                .context("Could not add rule to snat to sneaky IP")?;

                std::fs::write("/proc/sys/net/ipv4/conf/all/proxy_arp", "1")
                    .context("Could not enable proxy arp")?;
                std::fs::write(
                    format!("/proc/sys/net/ipv4/conf/{public_if}/proxy_arp"),
                    "1",
                )
                .context("Could not enable proxy arp")?;

                bb.execute(&[
                    "ip",
                    "route",
                    "add",
                    &format!("{ip}/32"),
                    "dev",
                    &format!("{ns_name}.0"),
                ])?;
            }
            None => {
                nft.exec(
                    format!(
                        "add rule inet {ns_name} postrouting oifname \"{public_if}\" masquerade"
                    ),
                    None,
                )
                .context("Could not add rule to masquerade traffic")?;
            }
        }

        Ok(DownloadContainer {
            ns_name,
            child,
            original_net_ns,
            child_net_ns,
            original_mnt_ns,
            child_mnt_ns,
            nft,
            wan_ip,
            lan_ip,
        })
    }

    /// Now that the container has been made, run a function in the environment
    ///
    /// ```no_run
    /// # use jj_rs::utils::{busybox, download_container::DownloadContainer};
    /// # fn test_download_container() -> eyre::Result<()> {
    /// let container = DownloadContainer::new(Some("dlshell".to_string()), None)?;
    /// let container_ip = container.run(|| {
    ///     busybox::execute(&["ip", "addr"])
    /// })??;
    /// assert!(container_ip.contains("172.16"));
    /// assert!(container_ip.contains("dlshell"));
    /// # Ok(())
    /// # }
    /// # test_download_container().expect("could not run download container");
    /// ```
    pub fn run<T, F: FnOnce() -> T>(&self, f: F) -> eyre::Result<T> {
        let cwd = unsafe { self.enter() }?;

        let v = f();

        self.leave(cwd)?;

        Ok(v)
    }

    /// Internal functions for jumping into the environment for run.
    ///
    /// This returns a directory that should be provided back to leave to restore
    /// the current working directory
    ///
    /// # Safety
    /// Needs to be matched with a call to [`DownloadContainer::leave`]
    pub unsafe fn enter(&self) -> eyre::Result<PathBuf> {
        let cwd = std::env::current_dir().context("Could not get current working directory")?;

        setns(&self.child_net_ns, CloneFlags::CLONE_NEWNET)
            .context("Could not change to child net namespace while entering container")?;
        // WHY WHY
        setns(&self.child_mnt_ns, CloneFlags::CLONE_NEWNS)
            .context("Could not change to child mount namespace while entering container")?;

        Ok(cwd)
    }

    /// Internal function for leaving the environment for run
    pub fn leave(&self, cwd: PathBuf) -> eyre::Result<()> {
        setns(&self.original_net_ns, CloneFlags::CLONE_NEWNET)
            .context("Could not change to parent net namespace while leaving container")?;
        setns(&self.original_mnt_ns, CloneFlags::CLONE_NEWNS)
            .context("Could not change to parent mount namespace while leaving container")?;

        std::env::set_current_dir(cwd)
            .context("Could not restore current working directory for download container")?;

        Ok(())
    }

    pub fn name(&self) -> &str {
        &self.ns_name
    }

    pub fn wan_ip(&self) -> Ipv4Addr {
        self.wan_ip
    }
}

impl Drop for DownloadContainer {
    fn drop(&mut self) {
        if let Err(e) = kill(self.child, SIGTERM) {
            return eprintln!(
                "Could not kill download container child with pid {}: {}",
                self.child, e
            );
        }

        if let Err(e) = waitpid(self.child, None) {
            return eprintln!(
                "Could not wait for download container child with pid {} to die: {}",
                self.child, e
            );
        }

        if let Err(e) = self
            .nft
            .exec(format!("delete table inet {}", self.ns_name), None)
        {
            eprintln!("Could not delete nftables namespace: {e}");
        }
    }
}

/// `busybox ip` doesn't actually support netns and creation of namespaces that
/// persist longer than processes
/// Instead, you can specify a pid of a process and move the link to their namespace
/// So, a process that just sleeps repeatedly until killed, allowing us to repeatedly
/// enter their namespace based on the /proc/pid/ns/net file
/// This will also create a new mount namespace that bind mounts a new file over
/// /etc/resolv.conf to enable outbound, external DNS that doesn't depend on the domain
/// controller
fn get_namespace(bb: &Busybox) -> eyre::Result<Pid> {
    // Semaphores are nasty but one of the simplest ways to communicate across
    // processes. We have to wait for the process to finish initializing, hence
    // shared memory and a shared semaphore
    use libc::sem_t;

    struct Sync {
        semaphore: sem_t,
        err: eyre::Result<()>,
    }

    const SYNC_SIZE: usize = std::mem::size_of::<Sync>();

    let setup_child = || -> eyre::Result<()> {
        nix::sched::unshare(CloneFlags::CLONE_NEWNET | CloneFlags::CLONE_NEWNS)
            .context("Could not unshare as child")?;

        let file_raw = bb.execute(&["mktemp"])?;
        let file = file_raw.trim();
        std::fs::write(file, "nameserver 1.1.1.1\n")?;
        std::fs::set_permissions(file, PermissionsExt::from_mode(0o555))?;

        nix::mount::mount(
            None::<&str>,
            "/",
            None::<&str>,
            nix::mount::MsFlags::MS_REC | nix::mount::MsFlags::MS_PRIVATE,
            None::<&str>,
        )?;

        nix::mount::mount(
            Some(file),
            "/etc/resolv.conf",
            None::<&str>,
            nix::mount::MsFlags::MS_BIND,
            None::<&str>,
        )?;

        Ok(())
    };

    unsafe {
        let sync: *mut Sync = libc::mmap(
            std::ptr::null_mut(),
            SYNC_SIZE,
            libc::PROT_READ | libc::PROT_WRITE,
            libc::MAP_ANONYMOUS | libc::MAP_SHARED,
            0,
            0,
        )
        .cast();
        let semaphore = &raw mut (*sync).semaphore;

        libc::sem_init(semaphore, 1, 0);

        match fork()? {
            ForkResult::Child => {
                (*sync).err = setup_child();

                libc::msync(sync.cast(), SYNC_SIZE, libc::MS_SYNC);
                libc::sem_post(semaphore);

                let _ = bb.execv(&["sleep", "infinity"]);
                loop {
                    std::thread::yield_now();
                }
            }
            ForkResult::Parent { child } => {
                libc::sem_wait(semaphore);
                libc::sem_destroy(semaphore);

                std::ptr::read(sync).err?;

                libc::munmap(semaphore.cast(), SYNC_SIZE);

                Ok(child)
            }
        }
    }
}

/// Finds a /30 subnet that can be used in the 172.16.0.0/12 range
/// to allow for tunneling between the host and the container
fn find_tunnel_net(bb: &Busybox) -> eyre::Result<Ipv4Addr> {
    let mut start_ip = 0xAC_20_00_00u32;

    let subnets = {
        let addrs = bb
            .execute(&["ip", "addr"])
            .context("Could not list current addresses")?;

        pcre!(&addrs =~ m{r"inet\s+(" IP_ADDR_REGEX r")/([0-9]+)"}xms)
            .into_iter()
            .map(|c| c.extract::<2>().1)
            .map(|[ip, sn]| {
                ip.parse::<Ipv4Addr>()
                    .context("could not parse IP provided by ip addr")
                    .and_then(|ip| {
                        sn.parse::<u32>()
                            .context("could not parse subnet mask from ip addr")
                            .map(|sn| (ip, sn))
                    })
            })
            .map(|sn_res| {
                sn_res.map(|(ip, sn)| {
                    (
                        u32::from(ip),
                        0xFF_FF_FF_FFu32
                            .overflowing_shr(32 - sn)
                            .0
                            .overflowing_shl(32 - sn)
                            .0,
                    )
                })
            })
            .collect::<Result<Vec<_>, _>>()?
    };

    'tunnel_ip_loop: loop {
        start_ip -= 4;

        for (sn_ip, sn_mask) in &subnets {
            if (start_ip & sn_mask) == (sn_ip & sn_mask) {
                continue 'tunnel_ip_loop;
            }
        }

        if (start_ip & 0xFF_F0_00_00) != 0xAC_10_00_00 {
            bail!(
                "IP address exhaustion when trying to find an IP address for download container!"
            );
        }

        return Ok(start_ip.into());
    }
}
